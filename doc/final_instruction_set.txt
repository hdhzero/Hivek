The Hivek processor is a 2-issue VLIW processor that aims to
save memory by using a variable instruction length.

There are 32 registers, 32 bits each

There are 5 instruction types:

------------
-- Type I --
------------
sz   op     immd12       rt    rs   cond
00 0tttt iiii iiii iiii sssss ttttt ccc
2 + 5 + 12 + 5 + 5 + 3 = 32

1 addi  rd, rs, immd
2 adci  rd, rs, immd
3 addis rd, rs, immd
4 adcis rd, rs, immd
5 andi  rd, rs, immd
6 ori   rd, rs, immd

8 cmpeqi  pd, rs, immd
9 cmplti  pd, rs, immd
A cmpgti  pd, rs, immd
B cmpltui pd, rs, immd
C cmpgtui pd, rs, immd

    - memory (8)
D lw  rd, rs, immd
E sw  rd, rs, immd
7 lb  rd, rs, immd
F sw  rd, rs, immd

-------------
-- Type II --
-------------
sz   op    immd26
00 100l ii iiii iiii iiii iiii iiii iiii
2 + 4 + 26 = 32
- j
- jal

Type III
sz  op        immd22                 cond
00 101lp  iii iiii iiii iiii ii  iiiii ccc
2 + 5 + 22 + 3 = 32

j cond



-------------
-- Type IV --
-------------
sz op    opcode      rd     rs    rt   cond
00 110 000 0000 0 0 ddddd ttttt sssss ccc

1 add  rd, rs, rt
2 sub  rd, rs, rt
3 adc  rd, rs, rt
4 sbc  rd, rs, rt
5 adds rd, rs, rt
6 adcs rd, rs, rt
7 subs rd, rs, rt
8 sbcs rd, rs, rt

9 shadd1 rd, rs, rt
10 shadd2 rd, rs, rt
11 shadd3 rd, rs, rt
12 shadd4 rd, rs, rt

13 and rd, rs, rt
14 or  rd, rs, rt
15 nor rd, rs, rt
16 xor rd, rs, rt

17 sll rd, rs, rt
18 slr rd, rs, rt
19 sar rd, rs, rt

20 slli rd, rs, immd
21 slri rd, rs, immd
22 sari rd, rs, immd
    
23 cmpeq  pd, rs, rt
24 cmplt  pd, rs, rt
25 cmpgt  pd, rs, rt
26 cmpltu pd, rs, rt
27 cmpgtu pd, rs, rt

28 andp pd, ps, pt
29 orp  pd, ps, pt
30 xorp pd, ps, pt
31 norp pd, ps, pt

32 andpi pd, ps, immd
33 orpi  pd, ps, immd
34 xorpi pd, ps, immd
35 norpi pd, ps, immd

36 jr
37 jalr
38 lw rd, rs, rt
39 sw rd, rs, rt
40 lb rd, rs, rt
41 sb rd, rs, rt
42 gsr rd   # get status registers: flags, carry, protection etc
43 ssr rd   # set status registers

Type V
00 111 uuu uuuu u uuuu uuuuu uuuuu uuuuu


- syscall
- atomic
- shift with carry
- bitwise complement and AND

src rd, ra
(rD)[0] ← MSR[C]
(rD)[1:31] ← (rA)[0:30]
MSR[C] ← (rA)[31]

while (v[i] == 0 && i < 10) {
    ++i;
}


r1 = v
r2 = i
loop:
        shadd r3, r1, r2 << 4 
        cmplti p2, r1, 10 ;;

	    lw r3, r3 ;;

        cmpeq p1, r3, r0 ;;

        andp p1, p1, p2 ;;

  (!p1) j loop
  (p1)  addi r2, r2, 1 ;;



while (*src) {
    *dst = *src;
    ++dst;
    ++src;
}

r1 = src
r2 = dst
loop:
        lw r5, r1 ;; 16

        cmpeq p1, r5, r0 ;; 32

  (!p1) sw r5, r2 32
  (!p1) j loop ;; 32

  (!p1) addi r1, r1, 1 32 bytes
  (!p1) addi r2, r2, 1 32 bytes


void double() {

}

00 00000 000 000 000
00 1ppcc cii iii iii
00 01111 000 000 000
00 01111 0 0000 0000
00 01111 0000 00000

1 add
2 sub
3 addi
4 lw
5 sw
6 lw fp
7 sw fp
8 mov
9 movi
A and
B or
C cmpeq
D cmplt
E cmpgt
F add

