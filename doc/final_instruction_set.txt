The Hivek processor is a 2-issue VLIW processor that aims to
save memory by using a variable instruction length.

There are 32 registers, 32 bits each

There are 5 instruction types:

------------
-- Type I --
------------
sz   op     immd12       rt    rs   cond
00 0tttt iiii iiii iiii sssss ttttt ccc
2 + 5 + 12 + 5 + 5 + 3 = 32

0 addi  rd, rs, immd
1 adci  rd, rs, immd
2 addis rd, rs, immd
3 adcis rd, rs, immd
4 andi  rd, rs, immd
5 ori   rd, rs, immd

6 cmpeqi  pd, rs, immd
7 cmplti  pd, rs, immd
8 cmpgti  pd, rs, immd
9 cmpltui pd, rs, immd
A cmpgtui pd, rs, immd

    - memory (8)
B lw  rd, rs, immd
C sw  rd, rs, immd
D lb  rd, rs, immd
E sw  rd, rs, immd

-------------
-- Type II --
-------------
sz   op    immd26
00 100l ii iiii iiii iiii iiii iiii iiii
2 + 4 + 26 = 32
- j
- jal

Type III
sz  op        immd22                 cond
00 101lp  iii iiii iiii iiii ii  iiiii ccc
2 + 5 + 22 + 3 = 32

j cond

-------------
-- Type IV --
-------------
sz op    opcode      rd     rs    rt   cond
00 110 000 0000 0 0 ddddd ttttt sssss ccc
2 + 3 + 9 + 5 + 5 + 5 + 3 = 32


opcodes:
# alu (5 bits)
1 add  rd, rs, rt
2 sub  rd, rs, rt
3 adc  rd, rs, rt
4 sbc  rd, rs, rt
5 adds rd, rs, rt
6 adcs rd, rs, rt
7 subs rd, rs, rt
8 sbcs rd, rs, rt

9  and rd, rs, rt
10 or  rd, rs, rt
11 nor rd, rs, rt
12 xor rd, rs, rt
13 sll rd, rs, rt 
14 slr rd, rs, rt
15 sar rd, rs, rt

# memory (2 bits)
16 lw rd, rs, rt
17 sw rd, rs, rt
18 lb rd, rs, rt
19 sb rd, rs, rt


# comparison (3 bits)
20 cmpeq  pd, rs, rt
21 cmplt  pd, rs, rt
22 cmpgt  pd, rs, rt
23 cmpltu pd, rs, rt
24 cmpgtu pd, rs, rt

# logical (2 bits)
25 andp pd, ps, pt
26 orp  pd, ps, pt
27 xorp pd, ps, pt
28 norp pd, ps, pt

# branch (1 bit)
29 jr rd
30 jalr rd

0tssiiiii
    - t: 0 - add, 1 - sub
    - ss: >>, << etc
    - iiiii: value to shift by

# shift (2 + 5 bits)
17 shadd1 rd, rs, rt
16 shsub  rd, rs, rt

22 slli rd, rs, immd # same as shadd rd, rs, r0
23 slri rd, rs, immd # same as sradd rd, rs, r0
24 sari rd, rs, immd # same as saaad rd, rs, r0

42 gsr rd   # get status registers: flags, carry, protection etc
43 ssr rd   # set status registers

Type V
00 111 uuu uuuu u uuuu uuuuu uuuuu uuuuu


- syscall
- atomic
- shift with carry
- bitwise complement and AND

src rd, ra
(rD)[0] ← MSR[C]
(rD)[1:31] ← (rA)[0:30]
MSR[C] ← (rA)[31]

while (v[i] == 0 && i < 10) {
    ++i;
}


r1 = v
r2 = i
loop:
        shadd r3, r1, r2 << 4 
        cmplti p2, r1, 10 ;;

	    lw r3, r3 ;;

        cmpeq p1, r3, r0 ;;

        andp p1, p1, p2 ;;

  (!p1) j loop
  (p1)  addi r2, r2, 1 ;;



while (*src) {
    *dst = *src;
    ++dst;
    ++src;
}

r1 = src
r2 = dst
loop:
        lw r5, r1 ;; 16

        cmpeq p1, r5, r0 ;; 32

  (!p1) sw r5, r2 32
  (!p1) j loop ;; 32

  (!p1) addi r1, r1, 1 32 bytes
  (!p1) addi r2, r2, 1 32 bytes


    add r1, r2, r3
    lw r5, r1

    lw r1, r1
    add r1, r1, r2
void double() {

}

00 00000 000 000 000
00 1pccc iii iii iii
00 01111 000 000 000
00 01111 0 0000 0000
00 01111 0000 00000

1 add    rd, rs, rt
2 sub    rd, rs, rt
3 addi   rd, rd, immd5
4 lw     rd, rs
5 sw     rd, rs
6 lw fp  rs, immd5
7 sw fp  rs, immd5
8 mov    rd, rs
9 movi   rs, immd5
A and    rd, rs, rt
B or     rd, rs, rt
C cmpeq  pd, rs, rt
D cmplt  pd, rs, rt
E cmpgt  pd, rs, rt
F addhi  rd, rs, rt

