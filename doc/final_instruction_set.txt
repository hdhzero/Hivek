The Hivek processor is a 2-issue VLIW processor that aims to
save memory by using a variable instruction length.

There are 32 registers, 32 bits each

There are 5 instruction types:

------------
-- Type I --
------------
sz   op     immd12       rt    rs   cond
00 0tttt iiii iiii iiii sssss ttttt ccc
2 + 5 + 12 + 5 + 5 + 3 = 32

1 addi  rd, rs, immd
2 adci  rd, rs, immd
3 addis rd, rs, immd
4 adcis rd, rs, immd
5 andi  rd, rs, immd
6 ori   rd, rs, immd

8 cmpeqi  pd, rs, immd
9 cmplti  pd, rs, immd
A cmpgti  pd, rs, immd
B cmpltui pd, rs, immd
C cmpgtui pd, rs, immd

    - memory (8)
D lw  rd, rs, immd
E sw  rd, rs, immd
7 lb  rd, rs, immd
F sw  rd, rs, immd

-------------
-- Type II --
-------------
sz   op    immd26
00 100l ii iiii iiii iiii iiii iiii iiii
2 + 4 + 26 = 32
- j
- jal

Type III
sz  op        immd22                 cond
00 101pp  iii iiii iiii iiii ii  iiiii ccc
2 + 5 + 22 + 3 = 32

j cond



-------------
-- Type IV --
-------------
sz op    opcode      rd     rs    rt   cond
00 110 000 0000 0 0 ddddd ttttt sssss ccc
add  rd, rs, rt
sub  rd, rs, rt
adc  rd, rs, rt
sbc  rd, rs, rt
adds rd, rs, rt
adcs rd, rs, rt
subs rd, rs, rt
sbcs rd, rs, rt

shadd1 rd, rs, rt
shadd2 rd, rs, rt
shadd3 rd, rs, rt
shadd4 rd, rs, rt



and rd, rs, rt
or  rd, rs, rt
nor rd, rs, rt
xor rd, rs, rt



sll rd, rs, rt
slr rd, rs, rt
sar rd, rs, rt

slli rd, rs, immd
slri rd, rs, immd
sari rd, rs, immd
    
cmpeq  pd, rs, rt
cmplt  pd, rs, rt
cmpgt  pd, rs, rt
cmpltu pd, rs, rt
cmpgtu pd, rs, rt

andp pd, ps, pt
orp  pd, ps, pt
xorp pd, ps, pt
norp pd, ps, pt

andpi pd, ps, immd
orpi  pd, ps, immd
xorpi pd, ps, immd
norpi pd, ps, immd

jr
jalr

Type V
00 111 uuu uuuu u uuuu uuuuu uuuuu uuuuu






- branch with delay slot
- jump relative to pc or absolute
- load adding two registers
- get and set status register
- syscall
- atomic
- shift with carry
- bitwise complement and AND

src rd, ra
(rD)[0] ← MSR[C]
(rD)[1:31] ← (rA)[0:30]
MSR[C] ← (rA)[31]

while (v[i] == 0 && i < 10) {
    ++i;
}


r1 = v
r2 = i
loop:
        shadd r3, r1, r2 << 4 
        cmplti p2, r1, 10 ;;

	    lw r3, r3 ;;

        cmpeq p1, r3, r0 ;;

        andp p1, p1, p2 ;;

  (!p1) j loop
  (p1)  addi r2, r2, 1 ;;



while (*src) {
    *dst = *src;
    ++dst;
    ++src;
}

r1 = src
r2 = dst
loop:
        lw r5, r1 ;; 16

        cmpeq p1, r5, r0 ;; 32

  (!p1) sw r5, r2 32
  (!p1) j loop ;; 32

  (!p1) addi r1, r1, 1 32 bytes
  (!p1) addi r2, r2, 1 32 bytes


void double() {

}

00 00000 000 000 000
00 1ppcc cii iii iii
00 01111 000 000 000
00 01111 0 0000 0000
00 01111 0000 00000

1 add
2 sub
3 addi
4 lw
5 sw
6 lw fp
7 sw fp
8 mov
9 movi
A and
B or
C cmpeq
D cmplt
E cmpgt
F add

